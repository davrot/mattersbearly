--- ./tmp_original_source/server/einterfaces/oidc.go	1970-01-01 01:00:00.000000000 +0100
+++ ./changed_files/server/einterfaces/oidc.go	2026-01-16 15:55:57.844046052 +0100
@@ -0,0 +1,140 @@
+// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
+// See LICENSE.txt for license information.
+
+package einterfaces
+
+import (
+	"context"
+	"encoding/json"
+	"errors"
+	"io"
+	"strings"
+
+	"github.com/coreos/go-oidc/v3/oidc"
+	"golang.org/x/oauth2"
+
+	"github.com/mattermost/mattermost/server/public/model"
+	"github.com/mattermost/mattermost/server/public/shared/mlog"
+	"github.com/mattermost/mattermost/server/public/shared/request"
+)
+
+const (
+	UserAuthServiceOIDC = "oidc"
+)
+
+type OIDCProvider struct {
+	provider *oidc.Provider
+	verifier *oidc.IDTokenVerifier
+	config   *oauth2.Config
+}
+
+func init() {
+	provider := &OIDCProvider{}
+	RegisterOAuthProvider(UserAuthServiceOIDC, provider)
+}
+
+func (op *OIDCProvider) GetUserFromJSON(rctx request.CTX, data io.Reader, tokenUser *model.User) (*model.User, error) {
+	var oidcUser model.OIDCUser
+	decoder := json.NewDecoder(data)
+	if err := decoder.Decode(&oidcUser); err != nil {
+		return nil, err
+	}
+
+	if err := oidcUser.IsValid(); err != nil {
+		return nil, err
+	}
+
+	return userFromOIDCUser(rctx.Logger(), &oidcUser), nil
+}
+
+func (op *OIDCProvider) GetUserFromIdToken(rctx request.CTX, idToken string) (*model.User, error) {
+	if op.verifier == nil {
+		return nil, errors.New("OIDC provider not initialized")
+	}
+
+	token, err := op.verifier.Verify(context.Background(), idToken)
+	if err != nil {
+		return nil, err
+	}
+
+	var oidcUser model.OIDCUser
+	if err := token.Claims(&oidcUser); err != nil {
+		return nil, err
+	}
+
+	if err := oidcUser.IsValid(); err != nil {
+		return nil, err
+	}
+
+	return userFromOIDCUser(rctx.Logger(), &oidcUser), nil
+}
+
+func (op *OIDCProvider) GetSSOSettings(rctx request.CTX, config *model.Config, service string) (*model.SSOSettings, error) {
+    return &model.SSOSettings{
+        Enable:          config.OIDCSettings.Enable,
+        Secret:          config.OIDCSettings.Secret,
+        Id:              config.OIDCSettings.Id,
+        Scope:           config.OIDCSettings.Scope,
+        AuthEndpoint:    config.OIDCSettings.DiscoveryEndpoint,
+        UserAPIEndpoint: config.OIDCSettings.DiscoveryEndpoint, // Changed 'Api' to 'API'
+        ButtonText:      config.OIDCSettings.ButtonText,
+        ButtonColor:     config.OIDCSettings.ButtonColor,
+    }, nil
+}
+
+func (op *OIDCProvider) IsSameUser(rctx request.CTX, dbUser, oauthUser *model.User) bool {
+	return dbUser.AuthData == oauthUser.AuthData
+}
+
+func userFromOIDCUser(logger mlog.LoggerIFace, oidcUser *model.OIDCUser) *model.User {
+	user := &model.User{}
+	
+	// Determine username - priority: uid > eduPersonPrincipalName (before @) > cn
+	username := oidcUser.UID
+	if username == "" && oidcUser.EduPersonPrincipalName != "" {
+		username = strings.Split(oidcUser.EduPersonPrincipalName, "@")[0]
+	}
+	if username == "" {
+		username = oidcUser.CommonName
+	}
+	user.Username = model.CleanUsername(logger, username)
+
+	// Set name fields
+	user.FirstName = oidcUser.GivenName
+	user.LastName = oidcUser.FamilyName
+	
+	// Email
+	user.Email = strings.ToLower(oidcUser.Email)
+	user.EmailVerified = oidcUser.EmailVerified
+
+	// Auth data - use sub (subject) as the unique identifier
+	userId := oidcUser.Sub
+	user.AuthData = &userId
+	user.AuthService = UserAuthServiceOIDC
+
+	// Store additional Keycloak attributes in Props
+	user.Props = make(map[string]string)
+	if oidcUser.EduPersonAffiliation != "" {
+		user.Props["eduPersonAffiliation"] = oidcUser.EduPersonAffiliation
+	}
+	if oidcUser.EduPersonEntitlement != "" {
+		user.Props["eduPersonEntitlement"] = oidcUser.EduPersonEntitlement
+	}
+	if oidcUser.ZfnScopedAffiliation != "" {
+		user.Props["zfnScopedAffiliation"] = oidcUser.ZfnScopedAffiliation
+	}
+	if oidcUser.EduPersonOrgUnitDN != "" {
+		user.Props["eduPersonOrgUnitDN"] = oidcUser.EduPersonOrgUnitDN
+	}
+	if oidcUser.UIDNumber != "" {
+		user.Props["uidNumber"] = oidcUser.UIDNumber
+	}
+	if len(oidcUser.Groups) > 0 {
+		groupsJSON, _ := json.Marshal(oidcUser.Groups)
+		user.Props["keycloakGroups"] = string(groupsJSON)
+	}
+
+	return user
+}
+
+
