--- /dev/null	2026-01-16 20:30:19.621000000 +0100
+++ ./changed_files/server/channels/app/oidc.go	2026-01-18 05:50:44.365926290 +0100
@@ -0,0 +1,311 @@
+// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
+// See LICENSE.txt for license information.
+
+package app
+
+import (
+	"context"
+	"encoding/json"
+	"errors"
+	"strings"
+    "fmt"
+
+	"github.com/coreos/go-oidc/v3/oidc"
+	"golang.org/x/oauth2"
+
+	"github.com/mattermost/mattermost/server/public/model"
+	"github.com/mattermost/mattermost/server/public/shared/mlog"
+	"github.com/mattermost/mattermost/server/public/shared/request"
+)
+
+const (
+	OIDCAuthService = "oidc"
+)
+
+
+// InitializeOIDCProvider initializes the OIDC provider
+func (a *App) InitializeOIDCProvider() error {
+	cfg := a.Config()
+	
+	if !*cfg.OIDCSettings.Enable {
+		return nil
+	}
+
+	provider, err := oidc.NewProvider(context.Background(), *cfg.OIDCSettings.DiscoveryEndpoint)
+	if err != nil {
+		return err
+	}
+
+	oauth2Config := oauth2.Config{
+		ClientID:     *cfg.OIDCSettings.Id,
+		ClientSecret: *cfg.OIDCSettings.Secret,
+		RedirectURL:  *cfg.ServiceSettings.SiteURL + "/oauth/oidc/complete",
+		Endpoint:     provider.Endpoint(),
+		Scopes:       strings.Split(*cfg.OIDCSettings.Scope, " "),
+	}
+
+	verifier := provider.Verifier(&oidc.Config{ClientID: *cfg.OIDCSettings.Id})
+
+	a.oidcProvider = provider
+	a.oidcConfig = &oauth2Config
+	a.oidcVerifier = verifier
+
+	return nil
+}
+
+// CompleteOIDCLogin handles the OIDC callback and creates/updates user
+func (a *App) CompleteOIDCLogin(c request.CTX, code, state string) (*model.User, error) {
+	if a.oidcConfig == nil || a.oidcVerifier == nil {
+		return nil, errors.New("OIDC not configured")
+	}
+
+	// Exchange code for token
+	oauth2Token, err := a.oidcConfig.Exchange(context.Background(), code)
+	if err != nil {
+		return nil, err
+	}
+
+	// Extract ID Token
+	rawIDToken, ok := oauth2Token.Extra("id_token").(string)
+	if !ok {
+		return nil, errors.New("no id_token in token response")
+	}
+
+	// Verify ID Token
+	idToken, err := a.oidcVerifier.Verify(context.Background(), rawIDToken)
+	if err != nil {
+		return nil, err
+	}
+
+	// Extract claims
+	var claims map[string]interface{}
+	if err := idToken.Claims(&claims); err != nil {
+		return nil, err
+	}
+
+	// Convert claims to OIDCUser
+	oidcUser, err := a.parseOIDCClaims(claims)
+	if err != nil {
+		return nil, err
+	}
+
+	// Find or create user
+	user, err := a.FindOrCreateOIDCUser(c, oidcUser, rawIDToken)
+	if err != nil {
+		return nil, err
+	}
+
+	// Update user details if configured
+	if *a.Config().OIDCSettings.UpdateUserDetailsOnLogin {
+		err = a.UpdateUserFromOIDC(c, user, oidcUser)
+		if err != nil {
+			c.Logger().Warn("Failed to update user details from OIDC", mlog.Err(err))
+		}
+	}
+
+	return user, nil
+}
+
+func (a *App) parseOIDCClaims(claims map[string]interface{}) (*model.OIDCUser, error) {
+	// Convert map to JSON and back to struct for easy parsing
+	jsonData, err := json.Marshal(claims)
+	if err != nil {
+		return nil, err
+	}
+
+	var oidcUser model.OIDCUser
+	if err := json.Unmarshal(jsonData, &oidcUser); err != nil {
+		return nil, err
+	}
+
+	// Handle 'email' claim if 'mail' is not present
+	if oidcUser.Email == "" {
+		if email, ok := claims["email"].(string); ok {
+			oidcUser.Email = email
+		}
+	}
+
+	return &oidcUser, nil
+}
+
+// FindOrCreateOIDCUser finds an existing user or creates a new one
+func (a *App) FindOrCreateOIDCUser(c request.CTX, oidcUser *model.OIDCUser, idToken string) (*model.User, error) {
+	authData := oidcUser.Sub
+	
+	// Try to find user by auth_data and auth_service
+	user, err := a.Srv().Store().User().GetByAuth(&authData, OIDCAuthService)
+	if err == nil {
+		return user, nil
+	}
+
+	// User not found by auth_data, try to find by email
+	user, err = a.Srv().Store().User().GetByEmail(oidcUser.Email)
+	if err != nil {
+		// User doesn't exist, check if auto-creation is allowed
+		if !a.isEmailDomainAllowed(oidcUser.Email) {
+			return nil, errors.New("user auto-creation not allowed for this email domain")
+		}
+
+		// Create new user
+        fullName := oidcUser.GivenName + " " + oidcUser.FamilyName
+        nickname := strings.TrimSpace(fullName)
+        if nickname == "" && oidcUser.Nickname != "" {
+            // Safer way to split: handles cases where there might not be an @
+            if atIndex := strings.Index(oidcUser.Nickname, "@"); atIndex != -1 {
+                nickname = oidcUser.Nickname[:atIndex]
+            } else {
+                nickname = oidcUser.Nickname
+            }
+        } 
+		user = &model.User{
+			Email:         strings.ToLower(oidcUser.Email),
+			EmailVerified: oidcUser.EmailVerified,
+			Username:      a.generateUsernameFromOIDC(oidcUser),
+			FirstName:     oidcUser.GivenName,
+			LastName:      oidcUser.FamilyName,
+            Nickname:      nickname,
+			AuthService:   OIDCAuthService,
+			AuthData:      &authData,
+			Props:         make(map[string]string),
+		}
+
+		// Store Keycloak attributes
+		a.setUserPropsFromOIDC(user, oidcUser)
+
+		createdUser, appErr := a.CreateUser(c, user)
+		if appErr != nil {
+			return nil, appErr
+		}
+
+		return createdUser, nil
+	}
+
+	// User exists but not linked to OIDC, link the account
+	if user.AuthService == "" || user.AuthService == model.UserAuthServiceEmail {
+		user.AuthService = OIDCAuthService
+		user.AuthData = &authData
+		user.EmailVerified = true
+
+		// Store Keycloak attributes
+		a.setUserPropsFromOIDC(user, oidcUser)
+
+		if _, appErr := a.Srv().Store().User().Update(c, user, true); appErr != nil {
+			return nil, appErr
+		}
+
+		return user, nil
+	}
+
+	// User exists with different auth service
+	return nil, errors.New("user already exists with different authentication method")
+}
+
+func (a *App) generateUsernameFromOIDC(oidcUser *model.OIDCUser) string {
+    var username string
+
+    // Use the field you actually have in your new struct
+    if oidcUser.Nickname != "" {
+        username = oidcUser.Nickname
+    } else {
+        username = strings.Split(oidcUser.Email, "@")[0]
+    }
+
+    cleanUsername := model.CleanUsername(a.Log(), username)
+
+    suggestedUsername := cleanUsername
+    for i := 1; i < 100; i++ {
+        // This is why this function belongs in 'app' - it needs the database Store
+        if _, err := a.Srv().Store().User().GetByUsername(suggestedUsername); err != nil {
+            return suggestedUsername
+        }
+        suggestedUsername = cleanUsername + fmt.Sprintf("%d", i)
+    }
+    
+    return cleanUsername
+}
+
+func (a *App) setUserPropsFromOIDC(user *model.User, oidcUser *model.OIDCUser) {
+	if user.Props == nil {
+		user.Props = make(map[string]string)
+	}
+}
+
+func (a *App) isEmailDomainAllowed(email string) bool {
+    // When the person is in the SSO, then we need to accect this person
+    return true
+}
+
+// UpdateUserFromOIDC updates user details from OIDC on each login
+func (a *App) UpdateUserFromOIDC(c request.CTX, user *model.User, oidcUser *model.OIDCUser) error {
+	user.FirstName = oidcUser.GivenName
+	user.LastName = oidcUser.FamilyName
+	user.Email = strings.ToLower(oidcUser.Email)
+	user.EmailVerified = oidcUser.EmailVerified
+
+    nickname := strings.TrimSpace(user.FirstName + " " + user.LastName)
+    if nickname == "" && oidcUser.Nickname != "" {
+        // Check for @ to avoid getting the whole email if you only want the prefix
+        if atIndex := strings.Index(oidcUser.Nickname, "@"); atIndex != -1 {
+            user.Nickname = oidcUser.Nickname[:atIndex]
+        } else {
+            user.Nickname = oidcUser.Nickname
+        }
+    } else {
+        user.Nickname = nickname
+    }
+
+
+	a.setUserPropsFromOIDC(user, oidcUser)
+
+	if _, appErr := a.Srv().Store().User().Update(c, user, true); appErr != nil {
+		return appErr
+	}
+
+	return nil
+}
+
+func (a *App) SetOAuthState(state string) {
+    // Store the state in the web session cache for 15 minutes.
+    // We use a prefix to avoid collisions with other OAuth providers.
+    a.Srv().Store().Token().Save(&model.Token{
+        Token:    state,
+        Type:     "oidc_state_" + state,
+        Extra:    "",
+        CreateAt: model.GetMillis(),
+    })
+}
+
+func (a *App) VerifyOAuthState(state string) bool {
+// Try to find the token in the store
+    token, err := a.Srv().Store().Token().GetByToken(state)
+    if err != nil {
+        return false
+    }
+
+    // Ensure it's the right type
+    if token.Type != "oidc_state_"+state {
+        return false
+    }
+
+    // Delete the token so it can't be reused (One-time use)
+    a.Srv().Store().Token().Delete(state)
+
+    // Check if it's expired (older than 15 minutes)
+    if model.GetMillis()-token.CreateAt > 15*60*1000 {
+        return false
+    }
+
+    return true
+}
+
+func (a *App) GetOIDCAuthURL(state string) string {
+    if a.oidcConfig == nil {
+        // Try to re-initialize if it was missed during startup
+        if err := a.InitializeOIDCProvider(); err != nil || a.oidcConfig == nil {
+            return ""
+        }
+    }
+    // AuthCodeURL generates the URL for the user to visit Keycloak/OIDC
+    return a.oidcConfig.AuthCodeURL(state, oauth2.AccessTypeOffline)
+}
+
